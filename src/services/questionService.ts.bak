import * as XLSX from 'xlsx';
import { Question } from '../types';

interface ExcelRow {
    A: number;
    B: string;
    C: string;
    D: string;
    E: string;
    F: string;
    [key: string]: any;
}

export const readQuestionsFromExcel = async (file: string): Promise<Question[]> => {
    try {
        // Read the workbook
        const workbook = XLSX.readFile(file);
        
        // Get the Questions sheet
        const worksheet = workbook.Sheets['Questions'];
        if (!worksheet) {
            throw new Error('Could not find Questions sheet in Excel file');
        }

        // Convert to raw JSON data with header row
        const jsonData = XLSX.utils.sheet_to_json<ExcelRow>(worksheet, { raw: true });
        console.log('Raw Excel data:', jsonData);

        const questions: Question[] = [];

        for (let i = 0; i < jsonData.length; i++) {
            const row = jsonData[i];
            if (!row || !row['A'] || !row['B'] || !row['C'] || !row['D'] || !row['E'] || !row['F']) {
                console.warn('Skipping row due to missing data:', row);
                continue;
            }

            // Find correct answer by checking cell styles
            let correctAnswer = 'А'; // Default
            for (const col of ['C', 'D', 'E', 'F']) {
                const cellRef = `${col}${i + 2}`; // +2 because Excel is 1-based and we have a header row
                const cell = worksheet[cellRef];
                if (cell && cell.s && cell.s.font && cell.s.font.color && 
                    (cell.s.font.color.rgb === '0000FF' || cell.s.font.color.rgb === '000000FF')) {
                    // Map Excel columns to answer options
                    correctAnswer = col === 'C' ? 'А' : col === 'D' ? 'Б' : col === 'E' ? 'В' : 'Г';
                    break;
                }
            }

            const question: Question = {
                id: parseInt(row['A'], 10),
                text: row['B'],
                options: {
                    'А': row['C'],
                    'Б': row['D'],
                    'В': row['E'],
                    'Г': row['F']
                },
                correctAnswer: correctAnswer
            };

            // Validate the question object
            if (isNaN(question.id) || !question.text || !Object.values(question.options).every(v => v)) {
                console.warn('Invalid question data:', question);
                continue;
            }

            questions.push(question);
        }

        if (questions.length === 0) {
            throw new Error('No valid questions found in Excel file');
        }

        console.log('Successfully loaded questions:', questions.length);
        return questions;
    // Read the workbook
    const workbook = XLSX.readFile(file);
    
    // Get the Questions sheet
    const worksheet = workbook.Sheets['Questions'];
    if (!worksheet) {
        throw new Error('Could not find Questions sheet in Excel file');
    }

    // Convert to raw JSON data
    const jsonData = XLSX.utils.sheet_to_json(worksheet);
    console.log('Raw Excel data:', jsonData);

    return jsonData.map((row: any, index: number) => {
        if (!row) return null;
        // Find correct answer by checking cell styles
        let correctAnswer = 'А'; // Default
        for (const col of ['C', 'D', 'E', 'F']) {
            const cellRef = `${col}${index + 2}`; // +2 because Excel is 1-based and we have a header row
            const cell = worksheet[cellRef];
            if (cell && cell.s && cell.s.font && cell.s.font.color && 
                (cell.s.font.color.rgb === '0000FF' || cell.s.font.color.rgb === '000000FF')) {
                // Map Excel columns to answer options
                correctAnswer = col === 'C' ? 'А' : col === 'D' ? 'Б' : col === 'E' ? 'В' : 'Г';
                break;
            }
        }

        if (!row['A'] || !row['B'] || !row['C'] || !row['D'] || !row['E'] || !row['F']) {
            console.warn('Skipping row due to missing data:', row);
            return null;
        }

        const question: Question = {
            id: parseInt(row['A'], 10),
            text: row['B'],
            options: {
                'А': row['C'],
                'Б': row['D'],
                'В': row['E'],
                'Г': row['F']
            },
            correctAnswer: correctAnswer as 'А' | 'Б' | 'В' | 'Г'
        };

        // Validate the question object
        if (isNaN(question.id) || !question.text || !Object.values(question.options).every(v => v)) {
            console.warn('Invalid question data:', question);
            return null;
        }

        return question
        };
    });
};
